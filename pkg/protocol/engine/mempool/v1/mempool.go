package mempoolv1

import (
	"context"

	"github.com/iotaledger/hive.go/core/memstorage"
	"github.com/iotaledger/hive.go/ds"
	"github.com/iotaledger/hive.go/ds/shrinkingmap"
	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/hive.go/lo"
	"github.com/iotaledger/hive.go/runtime/event"
	"github.com/iotaledger/hive.go/runtime/options"
	"github.com/iotaledger/hive.go/runtime/syncutils"
	"github.com/iotaledger/hive.go/runtime/workerpool"
	"github.com/iotaledger/iota-core/pkg/core/promise"
	"github.com/iotaledger/iota-core/pkg/core/vote"
	"github.com/iotaledger/iota-core/pkg/protocol/engine/mempool"
	"github.com/iotaledger/iota-core/pkg/protocol/engine/mempool/conflictdag"
	iotago "github.com/iotaledger/iota.go/v4"
)

// MemPool is a component that manages the state of transactions that are not yet included in the ledger state.
type MemPool[VoteRank conflictdag.VoteRankType[VoteRank]] struct {
	signedTransactionAttached *event.Event1[mempool.SignedTransactionMetadata]

	transactionAttached *event.Event1[mempool.TransactionMetadata]

	// executeStateTransition is the VM that is used to execute the state transition of transactions.
	executeStateTransition mempool.VM

	// resolveState is the function that is used to request state from the ledger.
	resolveState mempool.StateReferenceResolver

	// attachments is the storage that is used to keep track of the attachments of transactions.
	attachments *memstorage.IndexedStorage[iotago.SlotIndex, iotago.BlockID, *TransactionMetadata]

	// cachedTransactions holds the transactions that are currently in the MemPool.
	cachedTransactions *shrinkingmap.ShrinkingMap[iotago.TransactionID, *TransactionMetadata]

	// cachedSignedTransactions holds the signed transactions that are currently in the MemPool.
	cachedSignedTransactions *shrinkingmap.ShrinkingMap[iotago.SignedTransactionID, *SignedTransactionMetadata]

	// cachedStateRequests holds the requests for states that are required to execute transactions.
	cachedStateRequests *shrinkingmap.ShrinkingMap[iotago.Identifier, *promise.Promise[mempool.State]]

	// stateDiffs holds aggregated state mutations for each slot.
	stateDiffs *shrinkingmap.ShrinkingMap[iotago.SlotIndex, *StateDiff]

	// conflictDAG is the DAG that is used to keep track of the conflicts between transactions.
	conflictDAG conflictdag.ConflictDAG[iotago.TransactionID, iotago.OutputID, VoteRank]

	errorHandler func(error)

	// executionWorkers is the worker pool that is used to execute the state transitions of transactions.
	executionWorkers *workerpool.WorkerPool

	// lastEvictedSlot is the last slot that was evicted from the MemPool.
	lastEvictedSlot iotago.SlotIndex

	// evictionMutex is used to synchronize the eviction of slots.
	evictionMutex syncutils.RWMutex

	optForkAllTransactions bool

	apiProvider iotago.APIProvider
}

// New is the constructor of the MemPool.
func New[VoteRank conflictdag.VoteRankType[VoteRank]](vm mempool.VM, inputResolver mempool.StateReferenceResolver, workers *workerpool.Group, conflictDAG conflictdag.ConflictDAG[iotago.TransactionID, iotago.OutputID, VoteRank], apiProvider iotago.APIProvider, errorHandler func(error), opts ...options.Option[MemPool[VoteRank]]) *MemPool[VoteRank] {
	return options.Apply(&MemPool[VoteRank]{
		signedTransactionAttached: event.New1[mempool.SignedTransactionMetadata](),
		transactionAttached:       event.New1[mempool.TransactionMetadata](),
		executeStateTransition:    vm,
		resolveState:              inputResolver,
		attachments:               memstorage.NewIndexedStorage[iotago.SlotIndex, iotago.BlockID, *TransactionMetadata](),
		cachedTransactions:        shrinkingmap.New[iotago.TransactionID, *TransactionMetadata](),
		cachedSignedTransactions:  shrinkingmap.New[iotago.SignedTransactionID, *SignedTransactionMetadata](),
		cachedStateRequests:       shrinkingmap.New[iotago.Identifier, *promise.Promise[mempool.State]](),
		stateDiffs:                shrinkingmap.New[iotago.SlotIndex, *StateDiff](),
		executionWorkers:          workers.CreatePool("executionWorkers", 1),
		conflictDAG:               conflictDAG,
		apiProvider:               apiProvider,
		errorHandler:              errorHandler,
	}, opts, (*MemPool[VoteRank]).setup)
}

// AttachSignedTransaction adds a transaction to the MemPool that was attached by the given block.
func (m *MemPool[VoteRank]) AttachSignedTransaction(signedTransaction mempool.SignedTransaction, transaction mempool.Transaction, blockID iotago.BlockID) (signedTransactionMetadata mempool.SignedTransactionMetadata, err error) {
	storedSignedTransaction, isNewSignedTransaction, isNewTransaction, err := m.storeTransaction(signedTransaction, transaction, blockID)
	if err != nil {
		return nil, ierrors.Wrap(err, "failed to store signedTransaction")
	}

	if isNewSignedTransaction {
		m.signedTransactionAttached.Trigger(storedSignedTransaction)

		if isNewTransaction {
			m.transactionAttached.Trigger(storedSignedTransaction.transactionMetadata)

			m.solidifyInputs(storedSignedTransaction.transactionMetadata)
		}

	}

	return storedSignedTransaction, nil
}

func (m *MemPool[VoteRank]) OnTransactionAttached(handler func(transaction mempool.TransactionMetadata), opts ...event.Option) {
	m.transactionAttached.Hook(handler, opts...)
}

// MarkAttachmentOrphaned marks the attachment of the given block as orphaned.
func (m *MemPool[VoteRank]) MarkAttachmentOrphaned(blockID iotago.BlockID) bool {
	if attachmentSlot := m.attachments.Get(blockID.Slot(), false); attachmentSlot != nil {
		defer attachmentSlot.Delete(blockID)
	}

	return m.updateAttachment(blockID, (*TransactionMetadata).markAttachmentOrphaned)
}

// MarkAttachmentIncluded marks the attachment of the given block as included.
func (m *MemPool[VoteRank]) MarkAttachmentIncluded(blockID iotago.BlockID) bool {
	return m.updateAttachment(blockID, (*TransactionMetadata).markAttachmentIncluded)
}

// TransactionMetadata returns the metadata of the transaction with the given ID.
func (m *MemPool[VoteRank]) TransactionMetadata(id iotago.TransactionID) (transaction mempool.TransactionMetadata, exists bool) {
	return m.cachedTransactions.Get(id)
}

// OutputStateMetadata returns the metadata of the output state with the given ID.
func (m *MemPool[VoteRank]) OutputStateMetadata(stateReference *iotago.UTXOInput) (state mempool.OutputStateMetadata, err error) {
	stateRequest, exists := m.cachedStateRequests.Get(stateReference.StateID())

	if !exists || !stateRequest.WasCompleted() {
		stateRequest = m.requestState(stateReference)
	}

	stateRequest.OnSuccess(func(loadedState mempool.State) {
		switch loadedState.Type() {
		case iotago.InputUTXO:
			//nolint:forcetypeassert // we can safely assume that this is an OutputStateMetadata
			state = loadedState.(mempool.OutputStateMetadata)
		default:
			// as we are waiting for this Promise completion, we can assign the outer err
			err = ierrors.Errorf("invalid state type, only UTXO states can return metadata")
		}
	})
	stateRequest.OnError(func(requestErr error) { err = ierrors.Errorf("failed to request state: %w", requestErr) })
	stateRequest.WaitComplete()

	return state, err
}

// PublishCommitmentState publishes the given commitment state to the MemPool.
func (m *MemPool[VoteRank]) PublishCommitmentState(commitment *iotago.Commitment) {
	if stateRequest, exists := m.cachedStateRequests.Get(commitment.StateID()); exists {
		stateRequest.Resolve(commitment)
	}
}

// TransactionMetadataByAttachment returns the metadata of the transaction that was attached by the given block.
func (m *MemPool[VoteRank]) TransactionMetadataByAttachment(blockID iotago.BlockID) (mempool.TransactionMetadata, bool) {
	return m.transactionByAttachment(blockID)
}

// StateDiff returns the state diff for the given slot.
func (m *MemPool[VoteRank]) StateDiff(slot iotago.SlotIndex) mempool.StateDiff {
	if stateDiff, exists := m.stateDiffs.Get(slot); exists {
		return stateDiff
	}

	return NewStateDiff(slot)
}

// Evict evicts the slot with the given slot from the MemPool.
func (m *MemPool[VoteRank]) Evict(slot iotago.SlotIndex) {
	if evictedAttachments := func() *shrinkingmap.ShrinkingMap[iotago.BlockID, *TransactionMetadata] {
		m.evictionMutex.Lock()
		defer m.evictionMutex.Unlock()

		m.lastEvictedSlot = slot

		m.stateDiffs.Delete(slot)

		return m.attachments.Evict(slot)
	}(); evictedAttachments != nil {
		evictedAttachments.ForEach(func(blockID iotago.BlockID, transaction *TransactionMetadata) bool {
			transaction.evictAttachment(blockID)

			return true
		})
	}
}

func (m *MemPool[VoteRank]) storeTransaction(signedTransaction mempool.SignedTransaction, transaction mempool.Transaction, blockID iotago.BlockID) (storedSignedTransaction *SignedTransactionMetadata, isNewSignedTransaction, isNewTransaction bool, err error) {
	m.evictionMutex.RLock()
	defer m.evictionMutex.RUnlock()

	if m.lastEvictedSlot >= blockID.Slot() {
		// block will be retained as invalid, we do not store tx failure as it was block's fault
		return nil, false, false, ierrors.Errorf("blockID %d is older than last evicted slot %d", blockID.Slot(), m.lastEvictedSlot)
	}

	newTransaction, err := NewTransactionMetadata(transaction)
	if err != nil {
		return nil, false, false, ierrors.Errorf("failed to create transaction metadata: %w", err)
	}

	storedTransaction, isNewTransaction := m.cachedTransactions.GetOrCreate(newTransaction.ID(), func() *TransactionMetadata { return newTransaction })
	if isNewTransaction {
		m.setupTransaction(storedTransaction)
	}

	newSignedTransaction, err := NewSignedTransactionMetadata(signedTransaction, storedTransaction)
	if err != nil {
		return nil, false, false, ierrors.Errorf("failed to create signedTransaction metadata: %w", err)
	}

	storedSignedTransaction, isNewSignedTransaction = m.cachedSignedTransactions.GetOrCreate(lo.PanicOnErr(signedTransaction.ID()), func() *SignedTransactionMetadata { return newSignedTransaction })
	if isNewSignedTransaction {
		m.setupSignedTransaction(storedSignedTransaction, storedTransaction)
	}

	// TODO: figure out how to handle attachments and eviction
	storedSignedTransaction.addAttachment(blockID)
	m.attachments.Get(blockID.Slot(), true).Set(blockID, storedTransaction)

	return storedSignedTransaction, isNewSignedTransaction, isNewTransaction, nil
}

func (m *MemPool[VoteRank]) solidifyInputs(transaction *TransactionMetadata) {
	for i, inputReference := range transaction.inputReferences {
		stateReference, outputIndex := inputReference, i

		request, created := m.cachedStateRequests.GetOrCreate(stateReference.StateID(), func() *promise.Promise[mempool.State] {
			return m.requestState(stateReference, true)
		})

		request.OnSuccess(func(state mempool.State) {
			switch state.Type() {
			case iotago.InputUTXO:
				//nolint:forcetypeassert // we can safely assume that this is an OutputStateMetadata
				outputStateMetadata := state.(*OutputStateMetadata)

				transaction.publishInput(outputIndex, outputStateMetadata)

				if created {
					m.setupOutputState(outputStateMetadata)
				}
			case iotago.InputCommitment:
				//nolint:forcetypeassert // we can safely assume that this is an ContextStateMetadata
				contextStateMetadata := state.(*ContextStateMetadata)

				transaction.publishCommitmentInput(contextStateMetadata)

				if created {
					contextStateMetadata.onAllSpendersRemoved(func() { m.cachedStateRequests.Delete(contextStateMetadata.StateID()) })
				}
			case iotago.InputBlockIssuanceCredit, iotago.InputReward:
			default:
				panic(ierrors.New("invalid state type resolved"))
			}

			// an input has been successfully resolved, decrease the unsolid input counter and check solidity.
			if transaction.markInputSolid() {
				transaction.shouldExecute.OnTrigger(func() {
					m.executeTransaction(transaction)
				})
			}
		})

		request.OnError(transaction.setInvalid)
	}
}

func (m *MemPool[VoteRank]) executeTransaction(transaction *TransactionMetadata) {
	m.executionWorkers.Submit(func() {
		var timeReference mempool.ContextState
		if commitmentStateMetadata, ok := transaction.CommitmentInput().(*ContextStateMetadata); ok && commitmentStateMetadata != nil {
			timeReference = commitmentStateMetadata.State()
		}

		if outputStates, err := m.executeStateTransition(context.Background(), transaction.Transaction(), lo.Map(transaction.utxoInputs, (*OutputStateMetadata).State), timeReference); err != nil {
			transaction.setInvalid(err)
		} else {
			transaction.setExecuted(outputStates)

			m.bookTransaction(transaction)
		}
	})
}

func (m *MemPool[VoteRank]) bookTransaction(transaction *TransactionMetadata) {
	if m.optForkAllTransactions {
		m.forkTransaction(transaction, ds.NewSet(lo.Map(transaction.utxoInputs, (*OutputStateMetadata).OutputID)...))
	} else {
		lo.ForEach(transaction.utxoInputs, func(input *OutputStateMetadata) {
			input.OnDoubleSpent(func() {
				m.forkTransaction(transaction, ds.NewSet(input.OutputID()))
			})
		})
	}

	if !transaction.IsOrphaned() && transaction.setBooked() {
		m.publishOutputStates(transaction)
	}
}

func (m *MemPool[VoteRank]) forkTransaction(transaction *TransactionMetadata, resourceIDs ds.Set[iotago.OutputID]) {
	transaction.setConflicting()

	if err := m.conflictDAG.UpdateConflictingResources(transaction.ID(), resourceIDs); err != nil {
		transaction.setOrphaned()

		m.errorHandler(err)
	}
}

func (m *MemPool[VoteRank]) publishOutputStates(transaction *TransactionMetadata) {
	for _, output := range transaction.outputs {
		stateRequest, isNew := m.cachedStateRequests.GetOrCreate(output.StateID(), lo.NoVariadic(promise.New[mempool.State]))
		stateRequest.Resolve(output)

		if isNew {
			m.setupOutputState(output)
		}
	}
}

func (m *MemPool[VoteRank]) requestState(stateRef iotago.Input, waitIfMissing ...bool) *promise.Promise[mempool.State] {
	return promise.New(func(p *promise.Promise[mempool.State]) {
		request := m.resolveState(stateRef)

		request.OnSuccess(func(state mempool.State) {
			switch state.Type() {
			case iotago.InputUTXO:
				// The output was resolved from the ledger, meaning it was actually persisted as it was accepted and
				// committed: otherwise we would have found it in cache or the request would have never resolved.
				//nolint:forcetypeassert // we can safely assume that this is an OutputState
				outputStateMetadata := NewOutputStateMetadata(state.(mempool.OutputState))
				outputStateMetadata.setAccepted()
				outputStateMetadata.setCommitted()

				p.Resolve(outputStateMetadata)
			case iotago.InputCommitment:
				//nolint:forcetypeassert // we can safely assume that this is an ContextState
				commitmentStateMetadata := NewContextStateMetadata(state.(mempool.ContextState))

				p.Resolve(commitmentStateMetadata)
			case iotago.InputBlockIssuanceCredit, iotago.InputReward:
				p.Resolve(state)
			default:
				p.Reject(ierrors.Errorf("unsupported input type %s", stateRef.Type()))
			}
		})

		request.OnError(func(err error) {
			// do not reject the outer promise if the state was not found and the caller wants to wait for it
			if !lo.First(waitIfMissing) || !ierrors.Is(err, mempool.ErrStateNotFound) {
				p.Reject(err)
			}
		})
	})
}

func (m *MemPool[VoteRank]) updateAttachment(blockID iotago.BlockID, updateFunc func(transaction *TransactionMetadata, blockID iotago.BlockID) bool) bool {
	m.evictionMutex.RLock()
	defer m.evictionMutex.RUnlock()

	if m.lastEvictedSlot < blockID.Slot() {
		if transaction, exists := m.transactionByAttachment(blockID); exists {
			return updateFunc(transaction, blockID)
		}
	}

	return false
}

func (m *MemPool[VoteRank]) transactionByAttachment(blockID iotago.BlockID) (*TransactionMetadata, bool) {
	if attachmentsInSlot := m.attachments.Get(blockID.Slot()); attachmentsInSlot != nil {
		return attachmentsInSlot.Get(blockID)
	}

	return nil, false
}

func (m *MemPool[VoteRank]) updateStateDiffs(transaction *TransactionMetadata, prevIndex iotago.SlotIndex, newIndex iotago.SlotIndex) error {
	if prevIndex == newIndex {
		return nil
	}

	if prevIndex != 0 {
		if prevSlot, exists := m.stateDiffs.Get(prevIndex); exists {
			if err := prevSlot.RollbackTransaction(transaction); err != nil {
				return ierrors.Wrapf(err, "failed to rollback transaction, txID: %s", transaction.ID())
			}
		}
	}

	if transaction.IsAccepted() && newIndex != 0 {
		if stateDiff, evicted := m.stateDiff(newIndex); !evicted {
			if err := stateDiff.AddTransaction(transaction, m.errorHandler); err != nil {
				return ierrors.Wrapf(err, "failed to add transaction to state diff, txID: %s", transaction.ID())
			}
		}
	}

	return nil
}

func (m *MemPool[VoteRank]) setup() {
	m.conflictDAG.Events().ConflictAccepted.Hook(func(id iotago.TransactionID) {
		if transaction, exists := m.cachedTransactions.Get(id); exists {
			transaction.setConflictAccepted()
		}
	})
}

func (m *MemPool[VoteRank]) stateDiff(slot iotago.SlotIndex) (stateDiff *StateDiff, evicted bool) {
	if m.lastEvictedSlot >= slot {
		return nil, true
	}

	return lo.Return1(m.stateDiffs.GetOrCreate(slot, func() *StateDiff { return NewStateDiff(slot) })), false
}

func (m *MemPool[VoteRank]) setupTransaction(transaction *TransactionMetadata) {
	transaction.OnAccepted(func() {
		if slot := transaction.EarliestIncludedAttachment().Slot(); slot > 0 {
			if stateDiff, evicted := m.stateDiff(slot); !evicted {
				if err := stateDiff.AddTransaction(transaction, m.errorHandler); err != nil {
					m.errorHandler(ierrors.Wrapf(err, "failed to add transaction to state diff, txID: %s", transaction.ID()))
				}
			}
		}
	})

	transaction.OnConflicting(func() {
		m.conflictDAG.CreateConflict(transaction.ID())

		unsubscribe := transaction.parentConflictIDs.OnUpdate(func(appliedMutations ds.SetMutations[iotago.TransactionID]) {
			if err := m.conflictDAG.UpdateConflictParents(transaction.ID(), appliedMutations.AddedElements(), appliedMutations.DeletedElements()); err != nil {
				panic(err)
			}
		})

		transaction.OnEvicted(func() {
			unsubscribe()

			m.conflictDAG.EvictConflict(transaction.ID())
		})
	})

	transaction.OnEarliestIncludedAttachmentUpdated(func(prevBlock, newBlock iotago.BlockID) {
		if err := m.updateStateDiffs(transaction, prevBlock.Slot(), newBlock.Slot()); err != nil {
			m.errorHandler(ierrors.Wrap(err, "failed to update state diffs"))
		}
	})

	transaction.OnEvicted(func() {
		if m.cachedTransactions.Delete(transaction.ID()) {
			transaction.validAttachments.ForEach(func(blockID iotago.BlockID, _ bool) bool {
				if slotAttachments := m.attachments.Get(blockID.Slot(), false); slotAttachments != nil {
					slotAttachments.Delete(blockID)
				}

				return true
			})
		}
	})
}

func (m *MemPool[VoteRank]) setupOutputState(state *OutputStateMetadata) {
	state.OnCommitted(func() {
		if !m.cachedStateRequests.Delete(state.StateID(), state.HasNoSpenders) && m.cachedStateRequests.Has(state.StateID()) {
			state.onAllSpendersRemoved(func() { m.cachedStateRequests.Delete(state.StateID(), state.HasNoSpenders) })
		}
	})

	state.OnOrphaned(func() {
		m.cachedStateRequests.Delete(state.StateID())
	})
}

func (m *MemPool[VoteRank]) setupSignedTransaction(signedTransaction *SignedTransactionMetadata, transaction *TransactionMetadata) {
	transaction.OnSolid(func() {
		// Validate if signatures are valid and do something further
		//if err := validateSignatures(signedTransaction); err != nil {
		//	_ = signedTransaction.signaturesInvalid.Set(err)
		//
		//	return
		//}

		// if signatures are valid
		signedTransaction.signaturesValid.Trigger()
		signedTransaction.transactionMetadata.shouldExecute.Trigger()
	})

}

func WithForkAllTransactions[VoteRank conflictdag.VoteRankType[VoteRank]](forkAllTransactions bool) options.Option[MemPool[VoteRank]] {
	return func(m *MemPool[VoteRank]) {
		m.optForkAllTransactions = forkAllTransactions
	}
}

var _ mempool.MemPool[vote.MockedRank] = new(MemPool[vote.MockedRank])
